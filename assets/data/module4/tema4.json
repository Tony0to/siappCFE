{
    "sectionTitle": "IV. Otros paradigmas y su aplicaci√≥n",
    "sectionImage": "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQyNBIhwpBXeXWmFI9nY8LV30uEbACnT4Hjyg&s",
    "introText": "",
    "video": "",
    "subsections": [
      {
        "title": "1. Programaci√≥n funcional (profundizaci√≥n)",
        "content": "Aunque ya exploramos este paradigma en la secci√≥n de paradigmas cl√°sicos, vale la pena profundizar, porque muchos lenguajes modernos (como JavaScript, Python, Kotlin o Java) han adoptado caracter√≠sticas funcionales sin ser lenguajes funcionales puros.",
        "examples": [
          {
            "title": "Funciones puras",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "Definici√≥n:",
                "text": "Una funci√≥n pura es aquella que, dados los mismos valores de entrada, siempre devuelve los mismos valores de salida, sin modificar el estado global ni depender de variables externas."
              },
              {
                "subtitle": "Ventajas:",
                "text": "‚Ä¢ F√°cil de testear y depurar.\n‚Ä¢ Comportamiento predecible.\n‚Ä¢ Evita efectos colaterales."
              }
            ]
          },
          {
            "title": "Ejemplo de funci√≥n pura",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "Considera una funci√≥n que suma dos n√∫meros:"
              }
            ],
            "code": "const suma = (a, b) => a + b;\nconsole.log(suma(2, 3)); // Siempre devuelve 5",
            "explanation": "Esta funci√≥n es pura porque:\n‚Ä¢ No depende de variables externas.\n‚Ä¢ No modifica ning√∫n estado.\n‚Ä¢ Dados los mismos par√°metros (2 y 3), siempre devuelve 5."
          },
          {
            "title": "Inmutabilidad",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "Definici√≥n:",
                "text": "Los datos no cambian una vez que se asignan. En lugar de modificar una variable, se crea una nueva."
              }
            ]
          },
          {
            "title": "Ejemplo de inmutabilidad en Haskell",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "En Haskell, las variables son inmutables por defecto:"
              }
            ],
            "code": "let x = 5 in x + 1",
            "explanation": "Aqu√≠, 'x' se define como 5 y no puede cambiar. En lugar de modificar 'x', se crea un nuevo valor (x + 1), que es 6. Esto evita efectos colaterales y hace que el comportamiento sea m√°s predecible."
          },
          {
            "title": "Funciones de orden superior",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "Son funciones que pueden recibir otras funciones como argumentos o devolver funciones como resultado. Esto permite construir programas muy abstractos y potentes."
              }
            ]
          },
          {
            "title": "Ejemplo de funci√≥n de orden superior",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "En JavaScript, un ejemplo com√∫n es el m√©todo 'map':"
              }
            ],
            "code": "const numeros = [1, 2, 3];\nconst duplicados = numeros.map(num => num * 2);\nconsole.log(duplicados); // [2, 4, 6]",
            "explanation": "Aqu√≠, 'map' es una funci√≥n de orden superior que toma otra funci√≥n (num => num * 2) como argumento y la aplica a cada elemento del array. Esto permite transformar datos de forma declarativa y reutilizable."
          },
          {
            "title": "Aplicaciones actuales",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "‚Ä¢ An√°lisis y transformaci√≥n de grandes vol√∫menes de datos (big data).\n‚Ä¢ Sistemas financieros que requieren exactitud matem√°tica.\n‚Ä¢ Backend reactivo y procesamiento en tiempo real."
              }
            ]
          },
          {
            "title": "Dato curioso",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "Muchas librer√≠as modernas de JavaScript, como Redux y React, usan conceptos funcionales como inmutabilidad, composici√≥n y funciones puras para gestionar la l√≥gica de estado y las interfaces."
              }
            ]
          }
        ],
        "questions": [
          {
            "text": "¬øQu√© caracter√≠stica de la programaci√≥n funcional asegura que una funci√≥n siempre devuelva el mismo resultado para las mismas entradas?",
            "options": ["Inmutabilidad", "Funciones puras", "Event loop", "Encapsulamiento"],
            "correct": "Funciones puras"
          }
        ]
      },
      {
        "title": "2. Programaci√≥n basada en eventos",
        "content": "La programaci√≥n basada en eventos es un paradigma en el cual el flujo del programa se determina por eventos externos, como clics del usuario, mensajes del sistema, sensores o entradas de red. En lugar de ejecutarse de forma lineal, el programa 'reacciona' a lo que sucede.",
        "examples": [
          {
            "title": "Forma de pensar",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "‚ÄúEspera a que algo suceda, y luego responde.‚Äù"
              }
            ]
          },
          {
            "title": "Analog√≠a",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "Un mesero en un restaurante no act√∫a hasta que un cliente lo llama. Cada vez que recibe una se√±al (evento), √©l ejecuta una acci√≥n espec√≠fica."
              }
            ]
          },
          {
            "title": "Estructura com√∫n",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "‚Ä¢ Eventos: acciones que ocurren (clic, cambio, entrada de texto).\n‚Ä¢ Manejadores de eventos: funciones que se ejecutan cuando ocurre el evento.\n‚Ä¢ Ciclo de eventos (event loop): sistema que gestiona y despacha eventos cuando ocurren."
              }
            ]
          },
          {
            "title": "Ejemplo de programaci√≥n basada en eventos",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "En JavaScript, un ejemplo t√≠pico es manejar un clic en un bot√≥n:"
              }
            ],
            "code": "document.getElementById('miBoton').addEventListener('click', () => {\n  alert('¬°Bot√≥n clicado!');\n});",
            "explanation": "Aqu√≠, el evento es el 'click' en un bot√≥n con ID 'miBoton'. Cuando ocurre el evento, se ejecuta la funci√≥n manejadora, que muestra una alerta. El programa no hace nada hasta que el usuario interact√∫a."
          },
          {
            "title": "Aplicaciones modernas",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "‚Ä¢ Interfaces gr√°ficas interactivas.\n‚Ä¢ Juegos.\n‚Ä¢ Aplicaciones m√≥viles.\n‚Ä¢ Sistemas de monitoreo (como alarmas o sensores IoT).\n‚Ä¢ Chatbots y asistentes virtuales."
              }
            ]
          },
          {
            "title": "Dato curioso",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "El motor de eventos es el coraz√≥n de tecnolog√≠as como Node.js, que permite ejecutar miles de operaciones simult√°neas de forma eficiente."
              }
            ]
          }
        ],
        "questions": [
          {
            "text": "En la programaci√≥n basada en eventos, ¬øqu√© componente gestiona y despacha los eventos cuando ocurren?",
            "options": ["Manejador de eventos", "Ciclo de eventos (event loop)", "Funci√≥n pura", "Clase"],
            "correct": "Ciclo de eventos (event loop)"
          }
        ]
      },
      {
        "title": "3. Aplicaciones modernas y combinaci√≥n de paradigmas",
        "content": "En el desarrollo real de software, rara vez se usa un √∫nico paradigma. La mayor√≠a de los lenguajes y frameworks modernos permiten combinar paradigmas seg√∫n las necesidades del proyecto.",
        "examples": [
          {
            "title": "Ejemplo de combinaci√≥n",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "Una aplicaci√≥n web moderna puede incluir:\n‚Ä¢ Interfaz gr√°fica construida con eventos (React, Vue).\n‚Ä¢ L√≥gica del backend en POO (Java, Python).\n‚Ä¢ Consultas a bases de datos usando declarativo (SQL).\n‚Ä¢ Procesamiento de datos con t√©cnicas funcionales (map, reduce).\n‚Ä¢ Reglas del negocio expresadas con l√≥gica declarativa o basada en reglas."
              }
            ]
          },
          {
            "title": "Ventajas de combinar paradigmas",
            "color": "#4F46E5",
            "content": [
              {
                "subtitle": "",
                "text": "‚Ä¢ Mayor flexibilidad.\n‚Ä¢ Mejores herramientas para distintos tipos de problemas.\n‚Ä¢ C√≥digo m√°s expresivo y robusto."
              }
            ]
          },
          {
            "title": "Comparaci√≥n de paradigmas",
            "color": "#1E3A8A",
            "content": [
              {
                "subtitle": "",
                "text": "A continuaci√≥n, una tabla comparativa de los paradigmas de programaci√≥n:"
              }
            ],
            "table": [
              {
                "paradigma": "Programaci√≥n funcional",
                "como_piensa": "Evaluar expresiones matem√°ticas puras",
                "enfocado_en": "Inmutabilidad, funciones puras",
                "lenguajes_comunes": "Haskell, Scala, Clojure",
                "aplicaciones_tipicas": "Big data, sistemas financieros"
              },
              {
                "paradigma": "Programaci√≥n basada en eventos",
                "como_piensa": "Esperar eventos y reaccionar a ellos",
                "enfocado_en": "Flujo basado en eventos",
                "lenguajes_comunes": "JavaScript, Node.js",
                "aplicaciones_tipicas": "Interfaces gr√°ficas, juegos, IoT"
              },
              {
                "paradigma": "Programaci√≥n orientada a objetos",
                "como_piensa": "Modelar el mundo con objetos y clases",
                "enfocado_en": "Encapsulamiento, herencia",
                "lenguajes_comunes": "Java, Python, C#",
                "aplicaciones_tipicas": "Aplicaciones empresariales, frameworks"
              },
              {
                "paradigma": "Programaci√≥n l√≥gica",
                "como_piensa": "Definir reglas y dejar que el sistema infiera",
                "enfocado_en": "L√≥gica formal y reglas",
                "lenguajes_comunes": "Prolog, Mercury",
                "aplicaciones_tipicas": "Inteligencia artificial, sistemas expertos"
              },
              {
                "paradigma": "Programaci√≥n declarativa",
                "como_piensa": "Describir el qu√©, no el c√≥mo",
                "enfocado_en": "Resultados esperados",
                "lenguajes_comunes": "SQL, HTML, CSS",
                "aplicaciones_tipicas": "Bases de datos, dise√±o web"
              }
            ]
          },
          {
            "title": "üß† Reflexi√≥n final",
            "color": "#DC2626",
            "content": [
              {
                "subtitle": "",
                "text": "Comprender los paradigmas de programaci√≥n va mucho m√°s all√° de saber sintaxis o escribir l√≠neas de c√≥digo. Se trata de desarrollar la capacidad de elegir el enfoque m√°s adecuado para resolver un problema, dependiendo del contexto, los requisitos y los recursos disponibles."
              },
              {
                "subtitle": "üéØ ¬øQu√© me permite un paradigma?",
                "text": "‚Ä¢ Cambiar la forma en que pienso.\n‚Ä¢ Entender otras soluciones m√°s all√° de la m√≠a.\n‚Ä¢ Crear programas m√°s elegantes, mantenibles y eficientes."
              },
              {
                "subtitle": "",
                "text": "üí° En el mundo real, los proyectos exitosos combinan lo mejor de cada paradigma. Aprenderlos no es solo un requisito acad√©mico: es una inversi√≥n para tu futuro como programador."
              }
            ]
          }
        ],
        "questions": [
          {
            "text": "¬øCu√°l es una ventaja de combinar paradigmas en un proyecto de software?",
            "options": ["Menor flexibilidad", "C√≥digo m√°s expresivo y robusto", "Limitar las herramientas disponibles", "Aumentar la complejidad sin beneficios"],
            "correct": "C√≥digo m√°s expresivo y robusto"
          }
        ]
      }
    ]
  }